1
00:00:00,000 --> 00:00:03,200
이번 영상에서는 조금 색다른 것을 해보려고 합니다. 평소와는 다른 내용이 될 것입니다.

2
00:00:03,200 --> 00:00:07,360
React에서 특정 작업을 수행하는 방법을 보여드리고, 그것이 왜 더 나은지 설명해 드리겠습니다.

3
00:00:07,360 --> 00:00:11,840
이 방법으로 하세요, 다른 방법이 아니라. 대신에, 제가 여러분께 보여드릴 것은 제가...

4
00:00:11,840 --> 00:00:16,479
현재 그 프로젝트에서 겪었던 문제에 대한 해결책을 찾았고, 이를 작업 중에 있습니다. 이 해결책이 도움이 될 수도 있고 아닐 수도 있습니다.

5
00:00:16,479 --> 00:00:20,799
장기적으로는 맞지 않을 수도 있습니다. 그러니 준비하세요, 왜냐하면 이 비디오는 흥미로울 테니까요.

6
00:00:20,799 --> 00:00:24,559
그리고 여러분은 실제로 많은 것을 배우게 될 것입니다. 또한, 이 기회를 빌려 말씀드리고 싶습니다.

7
00:00:24,559 --> 00:00:28,639
React로 크고 복잡한 애플리케이션을 처음부터 끝까지 만드는 방법을 배우고 싶다면

8
00:00:28,639 --> 00:00:33,040
경험이 없는 초보자라면, 설명란에 있는 프로젝트 리액트를 확인해 보세요. 후회하지 않으실 겁니다.

9
00:00:33,040 --> 00:00:40,720
시작해봅시다. 자, 여기 제 VS 코드가 있습니다. 먼저 여러분께 보여드리겠습니다.

10
00:00:40,720 --> 00:00:45,200
실제 문제입니다. 그래서 저는 여기에서 루틴 API를 열려고 합니다. 제가 사용하고 있는 애플리케이션은

11
00:00:45,200 --> 00:00:49,919
"Building"은 습관 형성 앱입니다. 이 앱을 통해 다양한 루틴을 설정할 수 있습니다.

12
00:00:49,919 --> 00:00:53,840
당신은 루틴에 항목을 추가할 수 있죠, 그렇죠? 그래서 예를 들어 아침 루틴에는 일어나기 같은 것이 포함될 수 있습니다.

13
00:00:53,840 --> 00:00:57,599
침대를 정리하고, 이를 닦고, 그 외에도 여러 가지를 해야 합니다. 그리고 기본적으로 그것들을 해야 하고

14
00:00:58,000 --> 00:01:02,240
시간이 지남에 따라 연속적인 횟수로 계산됩니다. 이는 여러분의 일상을 개선하고 더 나은 습관을 형성하는 데 도움을 주기 위함입니다.

15
00:01:02,240 --> 00:01:06,080
자신을 더 나은 사람으로 만들기 위한 습관들. 이것이 이 애플리케이션의 전체적인 요지입니다.

16
00:01:06,080 --> 00:01:11,040
여기 이 파일이 실제로 프론트와 통신하는 실제 API 파일입니다.

17
00:01:11,040 --> 00:01:15,680
제 실제 애플리케이션과 백엔드, 데이터베이스를 종료합니다. 이 모든 작업은 드리즐을 사용하여 수행됩니다.

18
00:01:15,680 --> 00:01:20,639
ORM. 그래서 드리즐은 기본적으로 데이터베이스에 접근하기 위한 ORM과 같습니다. 그리고 저는 간단한 ORM을 사용하고 있습니다.

19
00:01:20,639 --> 00:01:25,760
SQLite 데이터베이스를 사용하여 모든 작업을 수행합니다. 그리고 이것이 실제 루틴과 관련된 모든 기능입니다.

20
00:01:25,760 --> 00:01:29,839
이 애플리케이션에서 주요 엔티티는 바로 그것입니다. 당신이 하는 모든 것은 실제로 그것과 관련이 있습니다.

21
00:01:29,839 --> 00:01:34,160
일상입니다. 여기 보시다시피, 저는 진행 중인 모든 일을 가지고 있습니다, 왜냐하면 저는

22
00:01:34,160 --> 00:01:38,639
지금 이 애플리케이션을 실제로 만들고 있습니다. 그리고 제가 어떻게 만드는지 직접 보실 수 있습니다.

23
00:01:38,639 --> 00:01:43,360
실시간으로, 말하자면, 고장난 상태에서, 일부 해결책이 있을 수도 있고 없을 수도 있는 상황에서

24
00:01:43,360 --> 00:01:46,480
맞아요. 그리고 저는 그들에 대해 이야기하고 싶어요. 왜냐하면 정말 흥미롭다고 생각하거든요. 그리고

25
00:01:46,480 --> 00:01:50,800
그들에게서 배울 점이 있어요. 그래서 저는 데이트를 위한 루틴을 얻기 위해 여기에 가고 싶어요. 그러니 함께 가봅시다.

26
00:01:50,800 --> 00:01:54,559
여기 아래로 스크롤하면 몇 가지 기능이 있습니다. 그리고 보세요, 우리는 get routines를 찾았습니다.

27
00:01:54,559 --> 00:01:59,360
날짜에 대한 것입니다. 이 함수는 날짜를 받아들이며, 이는 표준 날짜 객체입니다. 그리고

28
00:01:59,360 --> 00:02:03,919
그 특정 날짜에 예정된 모든 루틴을 가져올 것입니다. 루틴이 진행되는 방식은

29
00:02:03,919 --> 00:02:08,320
작업은 서로 다른 빈도를 가집니다. 따라서 루틴은 매일일 수도 있고, 매주일 수도 있으며,

30
00:02:08,320 --> 00:02:12,479
매달. 그리고 다른 날에도 가능하죠, 그렇죠? 그래서 매주 월요일, 수요일에 할 수도 있습니다.

31
00:02:12,479 --> 00:02:18,160
금요일, 매달 20일에 한 번씩, 이런 식으로 진행될 수 있습니다. 따라서 주어진 어떤 경우에도

32
00:02:18,160 --> 00:02:22,000
날짜에 따라 그 날짜에 예정된 루틴이 있을 수도 있고, 없을 수도 있습니다. 그리고 이 함수는

33
00:02:22,000 --> 00:02:26,240
특정 날짜에 예정된 모든 루틴을 담당합니다.

34
00:02:26,240 --> 00:02:30,240
그게 바로 그것이 하는 일입니다. 그래서 여기에서 보시다시피, 저는 먼저 실제 사용자를 얻고 있습니다.

35
00:02:30,240 --> 00:02:35,199
데이터베이스에서 db.query의 user 모델을 사용하여 첫 번째 사용자를 찾고 있습니다. 이 경우,

36
00:02:35,199 --> 00:02:39,600
이것은 로컬 애플리케이션입니다. 따라서 오프라인 우선으로 설계되었으며, 사용자는 항상 한 명만 있을 것입니다.

37
00:02:39,600 --> 00:02:43,520
그래서 첫 번째 사용자를 찾는 것이 안전합니다. 그리고 나서 첫 번째 사용자를 찾고 있습니다.

38
00:02:43,520 --> 00:02:47,919
모든 루틴을 확인하고 있습니다. 그리고 그 루틴 안에서 모든 빈도도 파악하고 있습니다. 그래서

39
00:02:47,919 --> 00:02:52,479
여기서의 주파수는 기본적으로 그 루틴의 빈도를 나타냅니다. 그것이 매일인가요? 그것이

40
00:02:52,479 --> 00:02:56,960
주간은 월간이며 특정한 날들이 무엇인지입니다. 여기 있는 버전들은 너무 신경 쓰지 마세요.

41
00:02:56,960 --> 00:03:01,039
그것에 주의를 기울이는 것은 기본적으로 제가 당신의 일상에 대한 변화를 추적하는 방법입니다. 따라서 만약

42
00:03:01,039 --> 00:03:05,039
일상에 변화를 줄 때마다, 저는 새로운 버전을 만듭니다. 그렇게 하면 모든 것을 볼 수 있습니다.

43
00:03:05,039 --> 00:03:09,600
변화가 있습니다. 그리고 과거의 일상도 잃지 않습니다. 왜냐하면 저는 그것을 분석에 사용하기 때문입니다.

44
00:03:09,600 --> 00:03:13,919
그리고 데이터를 확인합니다. 그런 다음 여기로 와서 사용자가 없으면 실제로 오류를 발생시킵니다.

45
00:03:13,919 --> 00:03:17,759
이것은 단지 예방 조치일 뿐이며, 항상 사용자가 있어야 하지만, 언제 어떻게 될지는 모르는 일이니 항상 더 나은 것이죠.

46
00:03:17,759 --> 00:03:21,679
오류를 발생시킨 후 이를 애플리케이션에서 잡아 처리하는 것입니다. 그리고 여기에는

47
00:03:21,679 --> 00:03:26,240
매우 더러운 무언가. 그래서 여기서 해야 할 일이 있는 거예요. 저는 기본적으로 수작업으로 하고 있습니다.

48
00:03:26,240 --> 00:03:30,080
루틴을 시간별로 정렬하는 것은 데이터베이스에서 해야 한다는 것을 알고 있지만, 그냥 하지 않았어요.

49
00:03:30,080 --> 00:03:33,919
지금 시간을 들여서 하고 싶어요. 왜냐하면 제가 주문하는 방식이 그렇게 간단하지 않기 때문이에요.

50
00:03:33,919 --> 00:03:36,880
다른 것들, 왜냐하면 저는 관계에 따라 정리하고 있기 때문입니다. 그리고 그것은 완전히 다른 것입니다.

51
00:03:36,880 --> 00:03:41,119
이야기. 그래서 그냥 이렇게 했어요. 그리고 해야 할 일로 두었고, 지금은 이대로 괜찮아요. 그리고 거기에

52
00:03:41,119 --> 00:03:45,440
우리는 가고, 저는 그냥 루틴을 정리하고 있어요. 그리고 여기 이 코드 조각이 있어요, 이거.

53
00:03:45,440 --> 00:03:50,240
모든 마법을 수행하는 코드 한 줄로, 우리는 기본적으로 정렬된 루틴을 전달하고 있습니다.

54
00:03:50,240 --> 00:03:54,559
여기에서 방금 주문한 루틴들을 이쪽으로 전달하고, 날짜와 함께 이 빌드 루틴으로 넘기고 있습니다.

55
00:03:54,559 --> 00:03:58,960
날짜 함수에 대한 것입니다. 그리고 여기 있는 이 함수가 문제입니다. 그래서 이 함수를 열어보면

56
00:03:58,960 --> 00:04:04,559
여기에서는 루틴 배열을 받습니다. 이 배열은 하나의 루틴과 그 버전들로 구성되어 있습니다. 그래서 그것은

57
00:04:04,559 --> 00:04:09,119
왜 우리가 여기에서 버전을 가져와야 했는지, 우리는 이 버전들을 필요로 합니다. 왜냐하면 그것들을 이쪽으로 전달해야 하기 때문입니다.

58
00:04:09,119 --> 00:04:13,919
여기서 함수는 버전을 사용하여 실제로 어떤 루틴이 있는지를 파악할 것입니다.

59
00:04:13,919 --> 00:04:17,760
그 특정 날짜에 마감됩니다. 이게 전체적인 작동 방식입니다. 이것은 제가 잘 모르는 코드 묶음입니다.

60
00:04:17,760 --> 00:04:21,920
이 모든 것을 어떻게 알아내는지에 대해서는 조금 복잡하기 때문에 자세히 들어가지는 않겠습니다.

61
00:04:21,920 --> 00:04:27,040
가장 중요한 것은 이 결과이며, 특히 그 결과의 유형입니다.

62
00:04:27,040 --> 00:04:31,760
여기에서 보시다시피, 우리는 결과를 선언하고 있습니다. 그리고 이것은 매우 복잡한 타입을 가지고 있습니다.

63
00:04:31,760 --> 00:04:36,000
루틴. 그리고 각 루틴에는 빈도가 있으며, 이 빈도 또한 이 루틴에 속합니다.

64
00:04:36,000 --> 00:04:40,000
빈도, 이것들은 일상의 관계입니다. 이것은 배열이며, 또한 우리는

65
00:04:40,000 --> 00:04:45,760
항목, 이는 일상적인 항목이며, 해당 특정 항목의 항목들도 모두

66
00:04:45,760 --> 00:04:50,799
여기에 배열이 있습니다. 그리고 버전도, 보시다시피, 이 모든 것을 반환하고 있습니다.

67
00:04:50,799 --> 00:04:55,440
저는 그냥 몇 가지 반복문을 돌리고 있어요. 그리고 마지막에는 결과 배열에 값을 추가하고 있습니다.

68
00:04:55,440 --> 00:05:00,160
그리고 저는 이 물체를 이쪽으로 밀고 있습니다. 이 물체에는 정기적인 빈도, 항목 및 버전이 포함되어 있습니다.

69
00:05:00,160 --> 00:05:04,959
여기에서 이 전체를 이 함수에 루틴으로 반환하고 있습니다. 그리고 이것이 반환되고 있습니다.

70
00:05:04,959 --> 00:05:09,519
이 특정 함수의 반환 값으로 사용됩니다. 그래서 여기 있는 이 타입이 제가 여러분께 요청하고 싶은 것입니다.

71
00:05:09,519 --> 00:05:14,559
집중해야 할 부분과 이것이 어떻게 이 함수로 되돌아오는지, 기본적으로 진행되고 있는 내용을 설명합니다.

72
00:05:14,559 --> 00:05:19,359
이 특정 함수의 반환 유형이 되어야 합니다. 그래서 문제가 뭐냐고 물으실 수 있는데, 음,

73
00:05:19,359 --> 00:05:24,160
문제는 여기 있는 이 유형과 관련이 있습니다. 이것은 이 특정 상황에만 해당하는 유형입니다.

74
00:05:24,160 --> 00:05:28,640
여기에서의 함수는 날짜를 위한 실제 함수 가져오기 루틴에 특화되어 있습니다.

75
00:05:28,640 --> 00:05:33,359
실제로 이 타입을 반환하는 경우, 저는 이 타입을 사용해야 하고, 내부의 값을 사용해야 합니다.

76
00:05:33,359 --> 00:05:38,079
실제 리액트 컴포넌트에서 이러한 유형을 사용하여 값을 표시하기 위해 작업을 수행합니다.

77
00:05:38,079 --> 00:05:42,480
특정 날짜에 항목이 있는지 확인하기 위해 항목을 표시하는 빈도를 설정하십시오.

78
00:05:42,480 --> 00:05:46,959
그래서, 제 리액트 컴포넌트에서 실제로 이 모든 속성을 사용해야 합니다.

79
00:05:46,959 --> 00:05:51,839
데이터를 실제 사용자에게 표시하기 위해 자료를 사용합니다. 문제는 제가 구성 요소를 만들어야 한다는 점입니다.

80
00:05:51,839 --> 00:05:56,799
이 데이터를 다루면서도 다양한 장소에서 재사용될 수 있도록 재사용 가능해야 합니다.

81
00:05:56,799 --> 00:06:01,600
실제 애플리케이션입니다. 여기서 보시다시피, 이것은 매우 특정한 유형이며, 이것은 루틴입니다.

82
00:06:01,600 --> 00:06:06,559
주파수와 함께 제공되는 항목들이 있습니다. 그리고 각각의 항목은 이러한 항목들과 함께 제공됩니다.

83
00:06:06,559 --> 00:06:11,040
또한 이 버전들도 함께 제공되는 루틴이 있어서, 저는 구체적으로 이 유형을 가져야 합니다.

84
00:06:11,040 --> 00:06:15,519
충분히 이해했으니, 이를 실제 리액트 컴포넌트에 넣어 예를 들어 routine.dot을 사용할 수 있도록 하겠습니다.

85
00:06:15,519 --> 00:06:19,760
주파수나 루틴이 아니라 버전입니다. 여기서 유형을 정확히 입력하지 않으면, 저는 아닙니다.

86
00:06:19,760 --> 00:06:23,760
그 특정 유형의 실제 값을 사용할 수 있게 될 것입니다. 예를 들어, 제가 왔을 때,

87
00:06:23,760 --> 00:06:28,239
API로 돌아와서, 이것을 마우스 오른쪽 버튼으로 클릭한 다음, 모든 참조 찾기로 이동하면, 그것은

88
00:06:28,239 --> 00:06:32,079
이 함수가 어디에서 사용되고 있는지 찾아주세요. 그리고 실제로 여기 안에서 사용되고 있습니다.

89
00:06:32,079 --> 00:06:37,359
이 쿼리 함수입니다. 그래서 이것은 React Query를 사용하고 있습니다. 여기에서 훅을 사용하고 있는데, 날짜를 위한 useRoutines입니다.

90
00:06:37,359 --> 00:06:41,440
쿼리입니다. 그리고 여기에서 이 함수를 실제로 사용하고 있습니다. 날짜에 대한 루틴을 가져오는 함수인데, 저는 이 함수에 인수를 전달하고 있습니다.

91
00:06:41,440 --> 00:06:46,799
날짜. 여기서 마우스 오른쪽 버튼을 클릭하고 이 훅의 참조로 이동하면, 저는 이것을 내부에서 사용하고 있습니다.

92
00:06:46,799 --> 00:06:51,279
여기 한 페이지에는 실제 일정 화면이 있고, 이것은 메인 홈 화면입니다.

93
00:06:51,279 --> 00:06:54,799
일정과 모든 날짜, 그리고 모든 루틴을 실제로 볼 수 있는 곳입니다.

94
00:06:54,799 --> 00:06:58,640
그 특정 날짜에 완료되었습니다. 그런데 여기서는 참고로 리액트 네이티브를 사용하고 있습니다만, 그것은

95
00:06:58,640 --> 00:07:02,559
이 비디오와는 전혀 상관없어요, 왜냐하면 모든 게 똑같거든요. 저는 그 훅을 사용하고 있어요.

96
00:07:02,559 --> 00:07:06,480
날짜 조회를 위해 루틴을 사용하고 있으며, 선택된 날짜는 상태로 저장된 값입니다.

97
00:07:06,480 --> 00:07:11,119
이 구성 요소의 내부입니다. 그리고 여기 있는 이 루틴들은 복잡한 유형을 가지고 있다는 것을 기억하세요.

98
00:07:11,119 --> 00:07:16,880
여기에서, 저는 이 컴포넌트, 즉 루틴 항목 목록에 직접 전달하고 있습니다.

99
00:07:16,880 --> 00:07:21,440
실제 날짜와 루틴을 전달합니다. 그리고 이제 이 구성 요소에 대해 이야기하자면, 중요한 점은 이 구성 요소가...

100
00:07:21,440 --> 00:07:26,959
구성 요소는 해당 특정 루틴의 올바른 유형을 가져야 합니다. 왜냐하면 그것을 모두 사용할 것이기 때문입니다.

101
00:07:26,959 --> 00:07:31,200
그 루틴의 단 하나의 요소. 하지만 문제는 이 부분이 여기에서,

102
00:07:31,200 --> 00:07:36,079
여기서 열고 타입을 잠시 무시하면, 이 부분은 루틴을 가져가고 그 다음에

103
00:07:36,079 --> 00:07:40,399
평평한 리스트를 사용하여 루틴을 매핑합니다. 이것은 단순히 항목들을 매핑하는 구성 요소입니다.

104
00:07:40,399 --> 00:07:44,799
효율적인 방법으로 데이터를 여기서 가져옵니다. 그런 다음 실제로 데이터를 수집합니다. 그리고 나서

105
00:07:44,799 --> 00:07:49,440
모든 요소마다 이 함수인 render item을 실행합니다. 여기서 이 item은 실제로

106
00:07:49,440 --> 00:07:54,480
루틴, 이 배열의 각 개별 항목. 그래서 우리는 이 루틴을 이 컴포넌트에 전달하고 있습니다.

107
00:07:54,480 --> 00:07:59,519
여기에서 루틴 입력 카드, 즉 이 구성 요소도 그 특정 유형을 가져야 한다는 것을 의미합니다.

108
00:07:59,519 --> 00:08:03,679
그 모든 특정한 속성을 가진 것이죠. 그런데 이 구성 요소를 열어보면, 보세요,

109
00:08:03,679 --> 00:08:07,359
여기에 타입을 두었습니다. 다시 한번 말씀드리지만, 타입은 무시하세요. 곧 이 부분을 다룰 예정입니다.

110
00:08:07,359 --> 00:08:12,079
이것은 루틴을 처리합니다. 그리고 여기에서는 다른 구성 요소에 전달하고 있습니다.

111
00:08:12,079 --> 00:08:16,880
루틴 입력 카드 메뉴와 루틴 입력 카드 진행 섹션. 이 두 가지는 다릅니다.

112
00:08:16,880 --> 00:08:20,959
구성 요소입니다. 그리고 이것은 정상입니다. 리액트 애플리케이션에서는 개별 구성 요소를 갖는 것이 바람직합니다.

113
00:08:20,959 --> 00:08:25,200
다양한 것들이 로직을 캡슐화하도록 하기 위해서입니다. 그리고 만약에 props를 받아야 한다면, 정의해야 합니다.

114
00:08:25,200 --> 00:08:29,359
그 소품들을 정의하고 타입을 지정하세요. 그래서 여기 이 컴포넌트가 있는데, 이는 같은 곳에서 정의됩니다.

115
00:08:29,359 --> 00:08:33,599
파일, 이것도 같은 유형의 루틴이 필요해요. 이해하고 계시길 바랍니다. 이해하고 계시길 바랍니다.

116
00:08:33,599 --> 00:08:37,760
제가 말하고자 하는 문제는 이 전체 상황에서 이 함수로 돌아가면 발생하는 것입니다.

117
00:08:37,760 --> 00:08:42,960
여기에서, 그리고 이 도우미는 어디에 있나요? 날짜를 위한 이 빌드 루틴에서, 저는 이 타입을 가져와야 합니다.

118
00:08:42,960 --> 00:08:49,200
이 특정 유형을 선택한 다음, 여기 있는 모든 구성 요소에 가서 그 유형으로 전달해야 합니다.

119
00:08:49,200 --> 00:08:53,679
특정 루틴에 대한 것이기 때문에, 저는 여기 와서 루틴 목록을 읽고 그것을 넘겨야 합니다.

120
00:08:53,679 --> 00:08:58,239
그 후에 여기로 와서 일상 출입 카드를 같은 방식으로 통과시키고, 다시 여기로 돌아와서 어떤 하위 항목으로 이동하세요.

121
00:08:58,239 --> 00:09:02,719
구성 요소를 전달하고 동일한 유형을 전달합니다. 그리고 이와 관련된 문제는 제가 여기로 올 때마다 발생한다는 것입니다.

122
00:09:02,719 --> 00:09:07,359
이 유형에서 무언가를 변경할 때, 주파수를 추가하거나 제거할 수도 있습니다.

123
00:09:07,359 --> 00:09:12,400
항목에 무언가를 추가할 때마다, 모든 항목에 대해 그것을 기억하고 다시 해야 합니다.

124
00:09:12,400 --> 00:09:16,479
이런 유형들은 제가 하고 싶지 않은 것들이에요. 그리고 그게 문제의 시작이었죠, 왜냐하면 저는 하고 싶지 않았거든요.

125
00:09:16,479 --> 00:09:21,359
이렇게 하세요. 이것은 매우 맞춤형 타입이라 다른 방법으로는 해결할 수 없습니다.

126
00:09:21,359 --> 00:09:25,280
이 타입을 복사해서 다른 모든 곳에 붙여넣어야 할 것입니다. 그리고 나머지는

127
00:09:25,280 --> 00:09:29,760
문제는 이 전체 유형을 효율적으로 처리하여 어떤 형태로든 정리할 방법을 찾지 못했다는 것입니다.

128
00:09:29,760 --> 00:09:34,000
재사용 가능한 타입을 사용자 정의할 수 있다는 거죠, 맞나요? 왜냐하면 어떤 화면에서는, 어떤 경우에는

129
00:09:34,000 --> 00:09:39,119
구성 요소에서는 주파수가 필요하지 않습니다. 다른 화면에서는 다른 항목들이 필요하지 않습니다.

130
00:09:39,119 --> 00:09:43,359
화면에 따라 버전이 필요 없을 수도 있습니다. 또는 어떤 화면에서는 이 중 두 가지만 필요할 수도 있습니다. 그리고 저는

131
00:09:43,359 --> 00:09:48,239
아마도 이것과는 별개로 세 번째 것이 필요할 수도 있습니다. 어떻게 하면 타입을 충분히 재사용 가능하게 구조화할 수 있을까요?

132
00:09:48,239 --> 00:09:53,359
모든 구성 요소에서 사용될 수 있으며, 그 구성 요소가 올바른

133
00:09:53,359 --> 00:09:58,000
제가 반복해서 말하지 않아도 타이핑할 수 있고, 실수할 가능성을 줄여줍니다.

134
00:09:58,000 --> 00:10:02,479
제가 추가한 모든 다른 곳에 무언가를 추가하는 것을 잊어버릴 때가 있습니다. 그래서 제가 찾은 해결책은

135
00:10:02,479 --> 00:10:06,719
다시 이 문제에 직면하게 되었는데, 또다시 더 나은 해결책이 없었기 때문입니다. 그리고 다시 말하지만, 이것은

136
00:10:06,719 --> 00:10:11,599
반드시 올바른 해결책이나 잘못된 해결책이 실제 반환 값을 취하는 것이라고 할 수는 없습니다.

137
00:10:11,599 --> 00:10:15,840
이 함수의 반환 타입은 여기 있는 이 함수에서 추론됩니다. 어디에 있나요?

138
00:10:15,840 --> 00:10:21,119
이것은 여기로 반환되어 날짜 함수의 get 루틴에 대한 반환 유형을 가져옵니다.

139
00:10:21,119 --> 00:10:26,479
여기서 보시다시피, 이 복잡한 타입을 가진 모든 것을 포함한 프로미스를 반환하며, 그런 다음 그것을 직접 사용할 수 있습니다.

140
00:10:26,479 --> 00:10:31,359
제 구성 요소에서, 여기에서는 루틴 입력 카드 목록, 정확히는 루틴 입력 목록을 다룹니다.

141
00:10:31,359 --> 00:10:35,359
그 일상들을 기다리고 있습니다. 왜냐하면 약속을 지키기 위해 기다리고 있기 때문입니다. 저는 돌아올 것을 기다리고 있습니다.

142
00:10:35,359 --> 00:10:40,960
약속을 하고, 그런 다음 반환 유형을 지정하고, 그런 다음 그 함수를 직접 호출합니다. 그리고 나서 이렇게 합니다.

143
00:10:40,960 --> 00:10:45,280
그리고 나서 이걸 루틴 입장 카드에 넘기면, 똑같이 합니다. 여기 와서, 이렇게 하죠.

144
00:10:45,280 --> 00:10:49,599
기다리던 반환 유형을 가진 후, 동일한 함수를 주고 그 함수를 숫자로 인덱싱합니다.

145
00:10:49,599 --> 00:10:54,320
각각의 루틴을 얻습니다. 그런 다음 이것을 가지고 다른 구성 요소가 있을 때마다,

146
00:10:54,320 --> 00:10:58,880
저도 같은 일을 합니다. 그것은 같은 유형의 반환 유형이고, 그런 다음 그것을 인덱싱합니다.

147
00:10:58,880 --> 00:11:04,239
특정 루틴을 얻기 위해 번호를 사용합니다. 이렇게 하는 것의 장점은 이제 제가 만약에

148
00:11:04,239 --> 00:11:09,520
여기로 오면 제가 이 타입에 무언가를 추가할 때, 저 타입에도 자동으로 반영될 것입니다.

149
00:11:09,520 --> 00:11:13,840
모든 함수에 걸쳐 전달되기 때문에 이를 사용하는 모든 구성 요소마다 필요합니다.

150
00:11:13,840 --> 00:11:18,159
이쪽에 있는 이 소품을 사용하여 모든 소품을 통해, await 반환 타입, 그리고 타입의

151
00:11:18,159 --> 00:11:22,960
실제 기능입니다. 이로 인한 이점은 이제 이러한 유형을 다시는 변경할 필요가 없다는 것입니다.

152
00:11:22,960 --> 00:11:27,039
그들은 기능과 연결되어 있습니다. 그래서 기능이 변경되면, 제가 여기서 무언가를 하면,

153
00:11:27,039 --> 00:11:31,280
저는 자동으로 모든 새로운 업데이트와 모든 그 가치들에 접근할 수 있게 될 것입니다.

154
00:11:31,280 --> 00:11:35,760
모든 구성 요소 내부에 직접적으로. 이것의 단점은, 그리고 제가 확신하지 못하는 부분은

155
00:11:35,760 --> 00:11:41,280
이제 모든 구성 요소가 이 함수 또는 다른 함수에 연결되어 있다는 점입니다.

156
00:11:41,280 --> 00:11:46,159
이 컴포넌트와 동일한 맞춤 방식으로 루틴을 반환하여, 이제 이

157
00:11:46,159 --> 00:11:51,440
구성 요소가 내가 원했던 만큼 재사용 가능하지 않은데, 그 이유는 특정 유형의 데이터를 기대하기 때문입니다.

158
00:11:51,440 --> 00:11:56,159
제 코드에서 특정 함수에서만 나오는 것입니다. 그래서 다른 곳에서 이를 재사용하고 싶다면,

159
00:11:56,159 --> 00:12:00,880
저는 이 함수를 사용하거나, 새로운 함수를 만들어야 합니다.

160
00:12:00,880 --> 00:12:06,080
이 특정 타입 제약 조건을 만족시키기 위해 동일한 타입 또는 충분히 겹치는 타입

161
00:12:06,080 --> 00:12:10,719
구성 요소. 그런데 문제는 이 패턴에 대해 100% 확신이 없다는 것입니다. 그래서 현재 상태는

162
00:12:10,719 --> 00:12:14,960
애플리케이션에는 제가 이 패턴을 어느 정도 테스트할 수 있을 만큼 충분한 구성 요소가 있습니다.

163
00:12:14,960 --> 00:12:19,760
아직까지는 아무 문제도 겪지 않았습니다. 하지만 애플리케이션이 완성되지 않았습니다. 그래서 제가 보장할 수는 없습니다.

164
00:12:19,760 --> 00:12:24,159
이 문제가 절대 발생하지 않을 것이며, 이 부품을 사용할 일이 절대 없을 것이라고 생각합니다.

165
00:12:24,159 --> 00:12:28,640
다른 곳에 있어야 해요. 그리고 다른 유형이어야 해요. 만약 그렇게 한다면, 제가 무엇을 할지 잘 모르겠어요.

166
00:12:28,640 --> 00:12:33,280
어떻게 하면 효율성을 유지하면서 이 타입을 변경할 수 있을지 잘 모르겠어요.

167
00:12:33,280 --> 00:12:37,840
여전히 반복하지 않도록 해주며, 확장성도 여전히 유지됩니다.

168
00:12:37,840 --> 00:12:41,919
미래에 더 많은 것을 쉽게 추가하고 싶을 경우를 대비해서. 실제로 가장 가까운 것은

169
00:12:41,919 --> 00:12:46,320
여기 루틴 API로 돌아가면, 여기에 또 다른 함수가 있습니다, 그것은

170
00:12:46,320 --> 00:12:50,799
날짜에 대한 get 루틴은 단일 루틴으로, ID를 받습니다. 이 ID는 루틴의 일부입니다.

171
00:12:50,799 --> 00:12:55,599
ID를 입력하세요. 그러면 같은 작업을 수행합니다. 하지만 여기에서는 동일한 함수인 build routines를 호출하고 있습니다.

172
00:12:55,599 --> 00:12:59,599
날짜에 대해, 우리는 루틴을 전달하고 있습니다. 그런 다음 그 배열에서 첫 번째 루틴을 가져옵니다.

173
00:12:59,599 --> 00:13:02,880
네, 그래서 우리는 같은 함수를 사용하고 있습니다. 이는 같은 타입을 사용하고 있다는 것을 의미합니다.

174
00:13:02,880 --> 00:13:07,119
그래서 두 화면에서 동일한 구성 요소를 사용할 수 있다는 뜻입니다. 지금까지는 저에게 잘 맞습니다.

175
00:13:07,119 --> 00:13:11,679
하지만 다시 말씀드리지만, 이것이 앞으로 영원히 효과가 있을 것이라고 보장할 수는 없습니다. 그리고 저는

176
00:13:11,679 --> 00:13:15,760
이것이 이 문제에 대한 좋은 해결책임을 보장합니다. 그리고 저는 먼저 이 영상을 만들고 싶었습니다.

177
00:13:15,760 --> 00:13:19,840
모든 것을 통해 이것이 전혀 문제 없다는 것을 보여드립니다. 애플리케이션에서는 다음과 같은 솔루션을 가질 수 있습니다.

178
00:13:19,840 --> 00:13:24,239
지금은 작동합니다. 그리고 내부에 더 나은 명백한 해결책이 없습니다. 그래서 그것을 적용합니다. 그리고 만약 나중에

179
00:13:24,239 --> 00:13:28,719
미래에 해결책이 더 이상 효과가 없게 되는 상황이 생긴다면, 그것을 바꾸는 것은 전혀 문제가 없습니다.

180
00:13:28,719 --> 00:13:32,960
특정 상황에 맞는 더 나은 해결책을 고안하고 적응하기 위해

181
00:13:32,960 --> 00:13:37,039
시간입니다. 또한, 실제로 그것이 어떤 것인지에 대한 통찰을 조금 나누고 싶었습니다.

182
00:13:37,039 --> 00:13:40,880
애플리케이션을 개발하다 보면 이러한 문제들을 자주 마주하게 될 것이며, 이를 해결하기 위한 능력을 키워야 합니다.

183
00:13:40,880 --> 00:13:45,919
적절한 시기에 올바른 해결책을 찾고, 그것이 최선이 아닐지라도 괜찮다고 여기는 능력

184
00:13:45,919 --> 00:13:50,640
완벽한 해결책입니다. 그리고 나중에 당신이 단지 마음이 바뀌었기 때문에 이것을 변경하는 것도 괜찮습니다.

185
00:13:50,640 --> 00:13:54,320
더 합리적인 해결책을 찾아보세요. 제 말은, 잘 생각해보면 그게 바로 제가 하고 있는 일입니다.

186
00:13:54,320 --> 00:13:58,880
여기에서, 날짜에 대한 루틴을 가져오기 위해 돌아가면, 모든 루틴을 가져오는 그 루틴을,

187
00:13:58,880 --> 00:14:03,280
여기 이 코드가 있는데, 이건 결코 좋은 해결책이 아니에요. 이건 정말로...

188
00:14:03,280 --> 00:14:07,679
비효율적이죠, 맞아요. 그래서 제가 여기서 실제로 적절한 정렬을 구현하도록 한 이유입니다.

189
00:14:07,679 --> 00:14:12,320
데이터베이스 수준에서 시간을 기준으로 하는 것이 더 효율적일 것입니다. 그러나 이 특정 경우에는

190
00:14:12,320 --> 00:14:16,880
이 프로젝트의 이 특정 시점에서는 이 해결책이 충분하며, 이는 저에게 허용합니다.

191
00:14:16,880 --> 00:14:21,440
프로젝트에 있어 현재 더 중요한 다른 분야에서 진전을 이루기 위해 이 부분은 잠시 미루겠습니다. 나중에 다시 검토할 수 있습니다.

192
00:14:21,440 --> 00:14:25,760
나중에 미래에. 이것이 최선의 해결책은 아니지만, 효과가 있고, 실제로 작동합니다.

193
00:14:25,760 --> 00:14:29,919
정확히 내가 원하는 것을 이루다. 그리고 또한, 대부분의 경우, 당신은 그렇지 않다는 사실을 생각해야 합니다.

194
00:14:29,919 --> 00:14:34,159
10개 이상의 루틴을 가질 예정입니다. 그래서 이것이 성능에 크게 영향을 미치지는 않을 것입니다.

195
00:14:34,159 --> 00:14:38,559
다시 말하지만, 이것은 전혀 문제 없습니다. 그리고 앞으로 이것을 바꿀 계획입니다, 단지 이유가 있어서입니다.

196
00:14:38,559 --> 00:14:42,320
그 특정 프로젝트에 추가하고 싶은 더 나은 해결책이 있을 것입니다. 그래서 거기에

197
00:14:42,320 --> 00:14:46,239
여기 있습니다. 이것이 제가 제 작업을 구축하는 방식에 대해 조금이나마 도움이 되었기를 바랍니다.

198
00:14:46,239 --> 00:14:50,000
리액트 애플리케이션을 직접 만들어 보세요. 이 비디오가 여러분에게 도움이 되었기를 바랍니다. 도움이 되었다면,

199
00:14:50,000 --> 00:14:54,000
이 영상에 큰 좋아요를 남겨주세요. 구독하려면 여기를 클릭하실 수 있습니다. 또는 클릭하여

200
00:14:54,000 --> 00:14:57,280
YouTube가 당신이 정말로 관심 있을 것이라고 생각하는 제 다른 영상을 보려면 여기를 클릭하세요.

201
00:14:57,280 --> 00:15:01,760
즐기세요. 그리고 이와 관련하여, 제 이름은 문제를 일으키고 해결책을 제공하는 이름입니다.

202
00:15:01,760 --> 00:15:05,599
시청해 주셔서 정말 감사합니다. 다음 영상에서 만나요. 차오, 차오.

